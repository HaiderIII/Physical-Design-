/* Simple Liberty Library for OpenSTA exercises */
library(simple) {
  delay_model : table_lookup;
  time_unit : "1ns";
  voltage_unit : "1V";
  current_unit : "1mA";
  capacitive_load_unit(1, pf);
  
  /* Threshold definitions */
  slew_lower_threshold_pct_rise : 20.0;
  slew_upper_threshold_pct_rise : 80.0;
  slew_lower_threshold_pct_fall : 20.0;
  slew_upper_threshold_pct_fall : 80.0;
  input_threshold_pct_rise : 50.0;
  input_threshold_pct_fall : 50.0;
  output_threshold_pct_rise : 50.0;
  output_threshold_pct_fall : 50.0;
  
  /* Default operating conditions */
  operating_conditions(typical) {
    process : 1.0;
    temperature : 25;
    voltage : 1.8;
  }
  default_operating_conditions : typical;

  /* ============================================ */
  /* INVERTER CELL                                */
  /* ============================================ */
  cell(INV) {
    area : 1.0;
    pin(A) {
      direction : input;
      capacitance : 0.01;
    }
    pin(Y) {
      direction : output;
      function : "!A";
      timing() {
        related_pin : "A";
        timing_sense : negative_unate;
        cell_rise(scalar) {
          values("0.05");
        }
        cell_fall(scalar) {
          values("0.04");
        }
        rise_transition(scalar) {
          values("0.02");
        }
        fall_transition(scalar) {
          values("0.02");
        }
      }
    }
  }

  /* ============================================ */
  /* 2-INPUT AND GATE                             */
  /* ============================================ */
  cell(AND2) {
    area : 2.0;
    pin(A) {
      direction : input;
      capacitance : 0.01;
    }
    pin(B) {
      direction : input;
      capacitance : 0.01;
    }
    pin(Y) {
      direction : output;
      function : "A & B";
      timing() {
        related_pin : "A";
        timing_sense : positive_unate;
        cell_rise(scalar) {
          values("0.08");
        }
        cell_fall(scalar) {
          values("0.07");
        }
        rise_transition(scalar) {
          values("0.03");
        }
        fall_transition(scalar) {
          values("0.03");
        }
      }
      timing() {
        related_pin : "B";
        timing_sense : positive_unate;
        cell_rise(scalar) {
          values("0.08");
        }
        cell_fall(scalar) {
          values("0.07");
        }
        rise_transition(scalar) {
          values("0.03");
        }
        fall_transition(scalar) {
          values("0.03");
        }
      }
    }
  }

  /* ============================================ */
  /* 2-INPUT OR GATE                              */
  /* ============================================ */
  cell(OR2) {
    area : 2.0;
    pin(A) {
      direction : input;
      capacitance : 0.01;
    }
    pin(B) {
      direction : input;
      capacitance : 0.01;
    }
    pin(Y) {
      direction : output;
      function : "A | B";
      timing() {
        related_pin : "A";
        timing_sense : positive_unate;
        cell_rise(scalar) {
          values("0.09");
        }
        cell_fall(scalar) {
          values("0.08");
        }
        rise_transition(scalar) {
          values("0.03");
        }
        fall_transition(scalar) {
          values("0.03");
        }
      }
      timing() {
        related_pin : "B";
        timing_sense : positive_unate;
        cell_rise(scalar) {
          values("0.09");
        }
        cell_fall(scalar) {
          values("0.08");
        }
        rise_transition(scalar) {
          values("0.03");
        }
        fall_transition(scalar) {
          values("0.03");
        }
      }
    }
  }

  /* ============================================ */
  /* 2-TO-1 MULTIPLEXER                           */
  /* ============================================ */
  cell(MUX2) {
    area : 4.0;
    pin(A) {
      direction : input;
      capacitance : 0.01;
    }
    pin(B) {
      direction : input;
      capacitance : 0.01;
    }
    pin(S) {
      direction : input;
      capacitance : 0.02;
    }
    pin(Y) {
      direction : output;
      function : "(S & B) | (!S & A)";
      timing() {
        related_pin : "A";
        timing_sense : positive_unate;
        cell_rise(scalar) {
          values("0.12");
        }
        cell_fall(scalar) {
          values("0.11");
        }
        rise_transition(scalar) {
          values("0.04");
        }
        fall_transition(scalar) {
          values("0.04");
        }
      }
      timing() {
        related_pin : "B";
        timing_sense : positive_unate;
        cell_rise(scalar) {
          values("0.12");
        }
        cell_fall(scalar) {
          values("0.11");
        }
        rise_transition(scalar) {
          values("0.04");
        }
        fall_transition(scalar) {
          values("0.04");
        }
      }
      timing() {
        related_pin : "S";
        timing_sense : non_unate;
        cell_rise(scalar) {
          values("0.15");
        }
        cell_fall(scalar) {
          values("0.14");
        }
        rise_transition(scalar) {
          values("0.05");
        }
        fall_transition(scalar) {
          values("0.05");
        }
      }
    }
  }
}
